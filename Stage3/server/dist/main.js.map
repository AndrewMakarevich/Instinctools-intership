{"version":3,"file":"main.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACZA,qBAAqB,mBAAO,CAAC,8DAAyB;;AAEtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B;AAC1C;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,wBAAwB;AACtC;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,wBAAwB;AACtC;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,KAAK;AACnB;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACjEA,oBAAoB,mBAAO,CAAC,4DAAwB;;AAEpD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,4BAA4B;AAC1C;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,KAAK;AACnB,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,KAAK;AACnB;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5EA,yBAAyB,mBAAO,CAAC,sEAA6B;;AAE9D;AACA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB,cAAc,4BAA4B;;AAE1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC;;AAEA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClGA,iBAAiB,mBAAO,CAAC,0BAAU;AACnC,iBAAiB,mBAAO,CAAC,wDAAsB;;AAE/C;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,WAAW,WAAW,MAAM,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mBAAmB;;;;;;;;;;;ACxEnB,iBAAiB,mBAAO,CAAC,wDAAsB;;AAE/C;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA,gCAAgC,sBAAsB;AACtD;;;;;;;;;;;ACPA,QAAQ,gBAAgB,EAAE,mBAAO,CAAC,0BAAU;;AAE5C;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,uCAAuC,GAAG,KAAK,iBAAiB,IAAI,SAAS,KAAK;AAClF;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,sBAAsB,K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","sources":["webpack://server/./src/apiError/apiError.js","webpack://server/./src/controller/groupController.js","webpack://server/./src/controller/userController.js","webpack://server/./src/controller/userGroupController.js","webpack://server/./src/db/index.js","webpack://server/./src/middleware/errorMiddleware.js","webpack://server/./src/models/models.js","webpack://server/./src/routes/groupRouter.js","webpack://server/./src/routes/index.js","webpack://server/./src/routes/userGroupRouter.js","webpack://server/./src/routes/userRouter.js","webpack://server/./src/service/groupService.js","webpack://server/./src/service/userGroupService.js","webpack://server/./src/service/userService.js","webpack://server/./src/utils/createModelSearchQuery.js","webpack://server/external commonjs \"cors\"","webpack://server/external commonjs \"dotenv\"","webpack://server/external commonjs \"express\"","webpack://server/external commonjs \"mongoose\"","webpack://server/webpack/bootstrap","webpack://server/./src/index.js"],"sourcesContent":["class ApiError extends Error {\n  constructor(code, message) {\n    super();\n    this.code = code;\n    this.message = message;\n  }\n\n  static badRequest(message) {\n    return new ApiError(400, message);\n  }\n}\n\nmodule.exports = ApiError;\n","const GroupService = require('../service/groupService');\n\nclass GroupController {\n  static async getGroup(req, res, next) {\n    try {\n      const groupsParamValueToFind = req.params.paramValue;\n      const groupsParamNameToFind = req.query.paramName;\n\n      const response = await GroupService.getGroup(\n        groupsParamNameToFind,\n        groupsParamValueToFind\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async getGroups(req, res, next) {\n    try {\n      const { filterObject, page, limit } = req.query;\n      const response = await GroupService.getGroups(filterObject, page, limit);\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async createGroup(req, res, next) {\n    try {\n      const { groupName, groupTitle } = req.body;\n      const response = await GroupService.createGroup(groupName, groupTitle);\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async editGroup(req, res, next) {\n    try {\n      const { id } = req.params;\n      const { groupName, groupTitle } = req.body;\n      const response = await GroupService.editGroup(id, groupName, groupTitle);\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async deleteGroup(req, res, next) {\n    try {\n      const { id } = req.params;\n      const response = await GroupService.deleteGroup(id);\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n}\n\nmodule.exports = GroupController;\n","const UserService = require('../service/userService');\n\nclass UserController {\n  static async getUser(req, res, next) {\n    try {\n      const usersParamValueToFind = req.params.paramValue;\n      const usersParamNameToFind = req.query.paramName;\n\n      const response = await UserService.getUser(\n        usersParamNameToFind,\n        usersParamValueToFind\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async getUsers(req, res, next) {\n    try {\n      const { filterObject, page, limit } = req.query;\n      const response = await UserService.getUsers(filterObject, page, limit);\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async createUser(req, res, next) {\n    try {\n      const { username, firstName, lastName, email } = req.body;\n      const userCreationResponse = await UserService.createUser(\n        username,\n        firstName,\n        lastName,\n        email\n      );\n\n      return res.json(userCreationResponse);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async editUser(req, res, next) {\n    try {\n      const { id } = req.params;\n      const { username, firstName, lastName, email } = req.body;\n      const response = await UserService.editUser(\n        id,\n        username,\n        firstName,\n        lastName,\n        email\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async deleteUser(req, res, next) {\n    try {\n      const { id } = req.params;\n      const response = await UserService.deleteUser(id);\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n}\n\nmodule.exports = UserController;\n","const UserGroupService = require('../service/userGroupService');\n\nclass UserGroupController {\n  static async getUserGroups(req, res, next) {\n    try {\n      const { userId } = req.params;\n      const { filterObject, page, limit } = req.query;\n      const response = await UserGroupService.getUsersGroups(\n        userId,\n        filterObject,\n        page,\n        limit\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async getGroupUsers(req, res, next) {\n    try {\n      const { groupId } = req.params;\n      const { filterObject, page, limit } = req.query;\n      const response = await UserGroupService.getGroupUsers(\n        groupId,\n        filterObject,\n        page,\n        limit\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async getNotGroupMembers(req, res, next) {\n    try {\n      const { groupId } = req.params;\n      const { filterObject, page, limit } = req.query;\n      const response = await UserGroupService.getNotGroupMembers(\n        groupId,\n        filterObject,\n        page,\n        limit\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async getGroupsUserNotParticipateIn(req, res, next) {\n    try {\n      const { userId } = req.params;\n      const { filterObject, page, limit } = req.query;\n\n      const response = await UserGroupService.getGroupsUserNotParticipateIn(\n        userId,\n        filterObject,\n        page,\n        limit\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async addUserToGroup(req, res, next) {\n    try {\n      const { userId, groupId } = req.body;\n      const response = await UserGroupService.addUserToGroup(userId, groupId);\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n\n  static async deleteUserFromGroup(req, res, next) {\n    try {\n      const { userId, groupId } = req.query;\n      const response = await UserGroupService.deleteUserFromGroup(\n        userId,\n        groupId\n      );\n\n      return res.json(response);\n    } catch (e) {\n      return next(e);\n    }\n  }\n}\n\nmodule.exports = UserGroupController;\n","const mongoose = require('mongoose');\nconst ApiError = require('../apiError/apiError');\n\nfunction connectToTheMongoDB() {\n  mongoose.connect('mongodb://localhost:27017/admin-panel-test-task', () => {\n    console.log('Connected to the mongoDB');\n  });\n}\n\nasync function checkForTheDuplication(Model, document, fieldsToCheck) {\n  async function findDuplicate(documentObj, paramName) {\n    const duplicate = await Model.findOne({\n      [paramName]: documentObj[paramName],\n    });\n\n    if (duplicate) {\n      throw ApiError.badRequest(\n        `${paramName} for ${Model.collection.name} must be unique`\n      );\n    }\n  }\n  const checkForDuplicates = [];\n  for (const fieldVal of fieldsToCheck) {\n    if (!Model.schema.obj[fieldVal]) {\n      continue;\n    }\n\n    if (Array.isArray(document)) {\n      for (const docVal of document) {\n        checkForDuplicates.push(findDuplicate(docVal, fieldVal));\n      }\n      continue;\n    }\n\n    checkForDuplicates.push(findDuplicate(document, fieldVal));\n  }\n  await Promise.all(checkForDuplicates);\n}\n\nfunction expandMongooseMethods() {\n  // OVERWRITE mongoose.Model.create method\n\n  const createRef = mongoose.Model.create;\n\n  mongoose.Model.create = async function (docs, options, callback) {\n    if (options && options.checkForDuplications) {\n      await checkForTheDuplication(this, docs, options.checkForDuplications);\n    }\n\n    return createRef.apply(this, arguments);\n  };\n\n  // OVERWRITE mongoose.Model.updateOne method\n\n  const updateRef = mongoose.Model.updateOne;\n\n  mongoose.Model.updateOne = async function (\n    filter,\n    update,\n    options,\n    callback\n  ) {\n    if (options && options.checkForDuplications) {\n      await checkForTheDuplication(this, update, options.checkForDuplications);\n    }\n\n    return updateRef.apply(this, arguments);\n  };\n}\n\nexpandMongooseMethods();\n\nmodule.exports = { connectToTheMongoDB, expandMongooseMethods };\n","const ApiError = require('../apiError/apiError');\n\nmodule.exports = (err, req, res, next) => {\n  if (err instanceof ApiError) {\n    return res.status(err.code).json({ message: err.message });\n  }\n  return res.status(500).json({ message: err.message });\n};\n","const { Schema, model } = require('mongoose');\n\nconst UserSchema = new Schema({\n  username: {\n    type: String,\n    unique: true,\n    match: [\n      /^[a-zA-Z0-9\\.,-]{4,20}$/,\n      \"Username does't match required pattern\",\n    ],\n  },\n\n  firstName: {\n    type: String,\n    match: [\n      /^[a-zA-Z]+\\s?[a-zA-Z]+$/,\n      \"First name does't match required pattern\",\n    ],\n    minlength: [2, 'First name is too short'],\n    maxlength: [20, 'First name is too long'],\n  },\n\n  lastName: {\n    type: String,\n    match: [/^[a-zA-Z]+$/, \"Last name does't match required pattern\"],\n    minlength: [2, 'Last name is too short'],\n    maxlength: [20, 'Last name is too long'],\n  },\n\n  email: {\n    type: String,\n    unique: true,\n    match: [\n      /^[a-zA-Z0-9!#$%&'\\*\\+\\-\\/=?^_`{}|]{1,65}@([a-zA-Z0-9]+.){1,2}[a-zA-Z]{2,14}$/,\n    ],\n  },\n});\n\nconst GroupSchema = new Schema({\n  groupName: {\n    type: String,\n    unique: true,\n    match: [\n      /^[a-zA-Z0-9.-]{4,20}$/,\n      \"Group's name doesn't match required pattern\",\n    ],\n  },\n\n  groupTitle: {\n    type: String,\n    match: [\n      /^[a-zA-Z0-9.-]{6,20}$/,\n      \"Group's title doesn't match required pattern\",\n    ],\n  },\n});\n\nconst UsersGroupsSchema = new Schema({\n  userId: {\n    type: Schema.Types.ObjectId,\n    ref: 'User',\n  },\n\n  groupId: {\n    type: Schema.Types.ObjectId,\n    ref: 'Group',\n  },\n});\n\nconst UserModel = model('User', UserSchema);\nconst GroupModel = model('Group', GroupSchema);\nconst UsersGroupsModel = model('UsersGroups', UsersGroupsSchema);\n\nmodule.exports = {\n  UserModel,\n  GroupModel,\n  UsersGroupsModel,\n};\n","const { Router } = require('express');\nconst GroupController = require('../controller/groupController');\n\nconst groupRouter = new Router();\n\ngroupRouter.get('/get/:paramValue', GroupController.getGroup);\ngroupRouter.get('/get-many', GroupController.getGroups);\ngroupRouter.post('/create', GroupController.createGroup);\ngroupRouter.put('/edit/:id', GroupController.editGroup);\ngroupRouter.delete('/delete/:id', GroupController.deleteGroup);\n\nmodule.exports = groupRouter;\n","const { Router } = require('express');\nconst groupRouter = require('./groupRouter');\nconst userGroupRouter = require('./userGroupRouter');\nconst userRouter = require('./userRouter');\n\nconst mainRouter = new Router();\n\nmainRouter.use('/user', userRouter);\nmainRouter.use('/group', groupRouter);\nmainRouter.use('/user-group', userGroupRouter);\n\nmodule.exports = mainRouter;\n","const { Router } = require('express');\nconst UserGroupController = require('../controller/userGroupController');\n\nconst userGroupRouter = new Router();\n\nuserGroupRouter.get('/get-groups/:userId', UserGroupController.getUserGroups);\nuserGroupRouter.get('/get-users/:groupId', UserGroupController.getGroupUsers);\nuserGroupRouter.get(\n  '/get-not-members/:groupId',\n  UserGroupController.getNotGroupMembers\n);\nuserGroupRouter.get(\n  '/get-groups-user-not-participate/:userId',\n  UserGroupController.getGroupsUserNotParticipateIn\n);\nuserGroupRouter.post('/add-user', UserGroupController.addUserToGroup);\nuserGroupRouter.delete('/delete-user', UserGroupController.deleteUserFromGroup);\n\nmodule.exports = userGroupRouter;\n","const { Router } = require('express');\nconst UserController = require('../controller/userController');\n\nconst userRouter = new Router();\n\nuserRouter.get('/get/:paramValue', UserController.getUser);\nuserRouter.get('/get-many', UserController.getUsers);\nuserRouter.post('/create', UserController.createUser);\nuserRouter.put('/edit/:id', UserController.editUser);\nuserRouter.delete('/delete/:id', UserController.deleteUser);\n\nmodule.exports = userRouter;\n","const ApiError = require('../apiError/apiError');\nconst { GroupModel } = require('../models/models');\nconst createModelSearchQuery = require('../utils/createModelSearchQuery');\n\nclass GroupService {\n  static async getGroup(paramName, paramValue) {\n    if (GroupModel.schema.obj[paramName] === undefined && paramName !== '_id') {\n      return null;\n    }\n\n    const group = await GroupModel.findOne({\n      [paramName]: paramValue,\n    });\n\n    return group;\n  }\n\n  static async getGroups(searchObj, pageNum, limitNum) {\n    const page = Number(pageNum) || 1;\n    const limit = Number(limitNum) || 5;\n\n    const searchQuery = createModelSearchQuery(searchObj);\n    const groupsCount = await GroupModel.count(searchQuery);\n    const groupsRows = await GroupModel.find(searchQuery)\n      .skip(limit * (page - 1))\n      .limit(limit);\n\n    return { count: groupsCount, rows: groupsRows };\n  }\n\n  static async createGroup(groupName, groupTitle) {\n    for (const arg of arguments) {\n      if (!arg) {\n        throw ApiError.badRequest('Not enough data for the Group creating');\n      }\n    }\n\n    const group = await GroupModel.create(\n      [\n        {\n          groupName,\n          groupTitle,\n        },\n      ],\n      { checkForDuplications: ['groupName'] }\n    );\n\n    return { message: `Group ${groupName} created successfully`, group };\n  }\n\n  static async editGroup(groupId, groupName, groupTitle) {\n    const groupToEdit = await GroupModel.findById(groupId).catch(() => {\n      throw ApiError.badRequest(\"Incorrect group's id\");\n    });\n\n    if (!groupToEdit) {\n      throw ApiError.badRequest(\"Group you try to edit doesn't exists\");\n    }\n\n    await GroupModel.updateOne(\n      { _id: groupId },\n      { groupName, groupTitle },\n      { checkForDuplications: ['groupName'], runValidators: true }\n    );\n\n    return { message: 'Group updated successfully' };\n  }\n\n  static async deleteGroup(groupId) {\n    const groupToDelete = await GroupModel.findById(groupId).catch(() => {\n      throw ApiError.badRequest(\"Incorrect group's id\");\n    });\n\n    if (!groupToDelete) {\n      throw ApiError.badRequest(\"Group you try to delete doesn't exists\");\n    }\n\n    const deletedGroup = await groupToDelete.deleteOne({ _id: groupId });\n\n    return { message: `Group deleted succesfully`, group: deletedGroup };\n  }\n}\n\nmodule.exports = GroupService;\n","const ApiError = require('../apiError/apiError');\nconst { GroupModel, UserModel, UsersGroupsModel } = require('../models/models');\nconst createModelSearchQuery = require('../utils/createModelSearchQuery');\n\nasync function checkUser(userId, userErrorMessage) {\n  const user = await UserModel.findById(userId).catch(() => {\n    throw ApiError.badRequest(\"Incorrect user's id\");\n  });\n\n  if (!user) {\n    throw ApiError.badRequest(userErrorMessage);\n  }\n\n  return user;\n}\n\nasync function checkGroup(groupId, groupErrorMessage) {\n  const group = await GroupModel.findById(groupId).catch(() => {\n    throw ApiError.badRequest(\"Incorrect group's id\");\n  });\n\n  if (!group) {\n    throw ApiError.badRequest(groupErrorMessage);\n  }\n\n  return group;\n}\n\nasync function checkUserAndGroup(\n  userId,\n  groupId,\n  userErrorMessage,\n  groupErrorMessage\n) {\n  const user = await checkUser(userId, userErrorMessage);\n  const group = await checkGroup(groupId, groupErrorMessage);\n\n  return { user, group };\n}\n\nclass UserGroupService {\n  static async getUserGroupConnection(userId, groupId) {\n    const userGroupRecord = await UsersGroupsModel.find({ userId, groupId });\n\n    return userGroupRecord;\n  }\n\n  static async getUsersGroups(userId, filterObject, page, limit) {\n    await checkUser(userId, \"User with such id doesn't exists\");\n\n    let userGroupsConnections = await UsersGroupsModel.find({\n      userId,\n    });\n\n    const parsedFilterObj = createModelSearchQuery(filterObject);\n    const skipValue = (page - 1) * limit;\n\n    // convert an array of user-group connections to the array of groups ids, wich have connection with the user\n    userGroupsConnections = userGroupsConnections.map((connection) =>\n      String(connection.groupId)\n    );\n\n    const userGroups = await GroupModel.find({\n      _id: { $in: [...userGroupsConnections] },\n      ...parsedFilterObj,\n    })\n      .skip(skipValue || 0)\n      .limit(limit || 5);\n\n    const userGroupsCount = await GroupModel.count({\n      _id: { $in: [...userGroupsConnections] },\n      ...parsedFilterObj,\n    });\n\n    return { count: userGroupsCount, rows: userGroups };\n  }\n\n  static async getGroupUsers(groupId, filterObject, page, limit) {\n    await checkGroup(groupId, \"Group with such id doesn't exists\");\n\n    let userGroupConnections = await UsersGroupsModel.find({\n      groupId,\n    });\n\n    if (!userGroupConnections) {\n      return [];\n    }\n\n    const parsedFilterObject = createModelSearchQuery(filterObject);\n    const skipValue = (page - 1) * limit;\n\n    userGroupConnections = userGroupConnections.map((connection) =>\n      String(connection.userId)\n    );\n\n    const users = await UserModel.find({\n      _id: { $in: [...userGroupConnections] },\n      ...parsedFilterObject,\n    })\n      .skip(skipValue || 0)\n      .limit(limit || 5);\n\n    const usersCount = await UserModel.count({\n      _id: { $in: [...userGroupConnections] },\n      ...parsedFilterObject,\n    });\n\n    return { count: usersCount, rows: users };\n  }\n\n  static async getNotGroupMembers(groupId, filterObject, page, limit) {\n    await checkGroup(groupId, \"Group with such id doesn't exists\");\n\n    let userGroupConnections = await UsersGroupsModel.find({\n      groupId,\n    });\n\n    if (!userGroupConnections) {\n      const allUsers = UserModel.find();\n      return allUsers;\n    }\n\n    const parsedFilterObj = createModelSearchQuery(filterObject);\n    const skipValue = (page - 1) * limit;\n\n    userGroupConnections = userGroupConnections.map(\n      (connection) => connection.userId\n    );\n    const notMembers = await UserModel.find({\n      _id: { $nin: userGroupConnections },\n      ...parsedFilterObj,\n    })\n      .skip(skipValue || 0)\n      .limit(limit || 5);\n\n    const notMembersCount = await UserModel.count({\n      _id: { $nin: userGroupConnections },\n      ...parsedFilterObj,\n    });\n\n    return { count: notMembersCount, rows: notMembers };\n  }\n\n  static async getGroupsUserNotParticipateIn(\n    userId,\n    filterObject,\n    page,\n    limit\n  ) {\n    await checkUser(userId, \"User with such id doesn't exists\");\n\n    const userGroupConnections = await UsersGroupsModel.find({\n      userId,\n    });\n\n    if (!userGroupConnections) {\n      const allGroups = GroupModel.find();\n      return allGroups;\n    }\n\n    const userGroupsIds = userGroupConnections.map(\n      (connection) => connection.groupId\n    );\n\n    const parsedFilterObj = createModelSearchQuery(filterObject);\n    const skipValue = (page - 1) * limit;\n\n    const groups = await GroupModel.find({\n      _id: { $nin: userGroupsIds },\n      ...parsedFilterObj,\n    })\n      .skip(skipValue || 0)\n      .limit(limit || 5);\n\n    const groupsCount = await GroupModel.count({\n      _id: { $nin: userGroupsIds },\n      ...parsedFilterObj,\n    });\n\n    return { count: groupsCount, rows: groups };\n  }\n\n  static async addUserToGroup(userId, groupId) {\n    const userAndGroup = await checkUserAndGroup(\n      userId,\n      groupId,\n      \"User you want add to the group, doesn't exists\",\n      \"Group in what you want to add the User, doesn't exists\"\n    );\n\n    const userGroupConnection = await UsersGroupsModel.findOne({\n      userId: userAndGroup.user._id,\n      groupId: userAndGroup.group._id,\n    });\n\n    if (userGroupConnection) {\n      throw ApiError.badRequest('User is already in the group');\n    }\n\n    await UsersGroupsModel.create({\n      userId: userAndGroup.user._id,\n      groupId: userAndGroup.group._id,\n    });\n\n    return {\n      message: `User ${userAndGroup.user.username} successfully added to the ${userAndGroup.group.groupName} group`,\n    };\n  }\n\n  static async deleteUserFromGroup(userId, groupId) {\n    const userAndGroup = await checkUserAndGroup(\n      userId,\n      groupId,\n      \"User you want to delete from the group, doesn't exists\",\n      \"Group in what you want to delete the User, doesn't exists\"\n    );\n\n    const userGroupConnection = await UsersGroupsModel.findOne({\n      userId: userAndGroup.user._id,\n      groupId: userAndGroup.group._id,\n    });\n\n    if (!userGroupConnection) {\n      throw ApiError.badRequest(\n        `Connection between ${userAndGroup.user.username}(User) and ${userAndGroup.group.groupName}(Group) doesn't exists`\n      );\n    }\n\n    userGroupConnection.deleteOne({ _id: userAndGroup.user.id });\n\n    return {\n      message: `User ${userAndGroup.user.username} successfully deleted from the group ${userAndGroup.group.groupName}`,\n    };\n  }\n}\n\nmodule.exports = UserGroupService;\n","const ApiError = require('../apiError/apiError');\nconst { UserModel } = require('../models/models');\nconst createModelSearchQuery = require('../utils/createModelSearchQuery');\n\nclass UserService {\n  static async getUser(paramName, paramValue) {\n    if (UserModel.schema.obj[paramName] === undefined && paramName !== '_id') {\n      return null;\n    }\n\n    const user = await UserModel.findOne({\n      [paramName]: paramValue,\n    });\n\n    return user;\n  }\n\n  static async getUsers(filterObj, pageNum, limitNum) {\n    const page = Number(pageNum) || 1;\n    const limit = Number(limitNum) || 5;\n\n    const searchQuery = createModelSearchQuery(filterObj);\n    const usersCount = await UserModel.count(searchQuery);\n    const usersRows = await UserModel.find(searchQuery)\n      .skip(limit * (page - 1))\n      .limit(limit);\n\n    return { count: usersCount, rows: usersRows };\n  }\n\n  static async createUser(username, firstName, lastName, email) {\n    for (const argValue of arguments) {\n      if (!argValue) {\n        throw ApiError.badRequest('Not enough data for the user creating');\n      }\n    }\n\n    const user = await UserModel.create(\n      [\n        {\n          username,\n          firstName,\n          lastName,\n          email,\n        },\n      ],\n      { checkForDuplications: ['username', 'email', 'what'] }\n    );\n\n    return { message: 'User created successfully', user };\n  }\n\n  static async editUser(userId, username, firstName, lastName, email) {\n    const userToEdit = await UserModel.findById(userId).catch(() => {\n      throw ApiError.badRequest(\"Incorrect user's id\");\n    });\n\n    if (!userToEdit) {\n      throw ApiError.badRequest(\"User you try to edit doesn't exists\");\n    }\n\n    await UserModel.updateOne(\n      { _id: userId },\n      {\n        username,\n        firstName,\n        lastName,\n        email,\n      },\n      { checkForDuplications: ['username', 'email'], runValidators: true }\n    );\n\n    return { message: 'User updated successfully' };\n  }\n\n  static async deleteUser(userId) {\n    const userToDelete = await UserModel.findById(userId).catch(() => {\n      throw ApiError.badRequest(\"Incorrect user's id\");\n    });\n\n    if (!userToDelete) {\n      throw ApiError.badRequest(\"User you try to delete doesn't exists\");\n    }\n    const user = await userToDelete.deleteOne({ _id: userId });\n\n    return { message: 'User deleted successfully', user };\n  }\n}\n\nmodule.exports = UserService;\n","const ApiError = require('../apiError/apiError');\n\nfunction createModelSearchQuery(obj) {\n  if (!obj) {\n    return {};\n  }\n\n  let parsedObj;\n  if (obj) {\n    try {\n      parsedObj = JSON.parse(obj);\n    } catch (e) {\n      throw ApiError.badRequest(e);\n    }\n  }\n\n  const finalObject = {};\n\n  function fillFinalObject(mockObj, paramName = '') {\n    Object.keys(mockObj).forEach((objKey) => {\n      if (typeof mockObj[objKey] === 'object') {\n        const newParamName = paramName.length\n          ? `${paramName}.${objKey}`\n          : objKey;\n\n        return fillFinalObject(mockObj[objKey], newParamName);\n      }\n\n      const finalObjectParamName = paramName.length\n        ? `${paramName}.${objKey}`\n        : objKey;\n      const numberRange = mockObj[objKey].split('|');\n\n      if (numberRange.length !== 2) {\n        finalObject[finalObjectParamName] = {\n          $regex: mockObj[objKey],\n          $options: 'gi',\n        };\n      } else {\n        if (Number(numberRange[0])) {\n          finalObject[finalObjectParamName] = {\n            ...finalObject[finalObjectParamName],\n            $gte: numberRange[0],\n          };\n        }\n\n        if (Number(numberRange[1])) {\n          finalObject[finalObjectParamName] = {\n            ...finalObject[finalObjectParamName],\n            $lte: numberRange[1],\n          };\n        }\n      }\n    });\n  }\n\n  fillFinalObject(parsedObj);\n\n  return finalObject;\n}\n\nmodule.exports = createModelSearchQuery;\n","module.exports = require(\"cors\");","module.exports = require(\"dotenv\");","module.exports = require(\"express\");","module.exports = require(\"mongoose\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","require('dotenv').config();\nconst express = require('express');\nconst cors = require('cors');\nconst { connectToTheMongoDB } = require('./db');\nconst errorMiddleware = require('./middleware/errorMiddleware');\nconst mainRouter = require('./routes');\n\nconst app = express();\napp.use(\n  cors({\n    origin: [process.env.FRONT_APP_LINK, 'http://localhost'],\n  })\n);\napp.use(express.json());\napp.use('/api', mainRouter);\napp.use(errorMiddleware);\nconst PORT = process.env.PORT || 5000;\n\nasync function start() {\n  try {\n    connectToTheMongoDB();\n    app.listen(PORT, () => {\n      console.log(`Server started at port ${PORT}`);\n    });\n  } catch (e) {\n    console.log(e);\n  }\n}\nstart();\n"],"names":[],"sourceRoot":""}